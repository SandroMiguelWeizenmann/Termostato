/* Main.c file generated by New Project wizard
 *
 * Created:   seg abr 29 2019
 * Processor: PIC18F4520
 * Compiler:  MPLAB XC8
 */

# include <xc.h>
# include <stdint.h>
# define _XTAL_FREQ 16000000

# define HREC PORTBbits.RB0
# define TEMPERATURA PORTBbits.RB1	// usado para alternar exibição entre as temperaturas limite (max/min)
# define TEMP_TERM PORTAbits.RA4	// usado para exibição da temperatura do termometro

# define LED_MIN PORTAbits.RA5
# define LED_MAX PORTAbits.RA6
# define LED_TERM PORTAbits.RA3
# define LED_ACIMA PORTCbits.RC5
# define LED_DENTRO PORTCbits.RC6
# define LED_ABAIXO PORTCbits.RC7

# define SDA PORTCbits.RC4
# define SCL PORTCbits.RC3
# define TRIS_SDA TRISCbits.RC4
# define TRIS_SCL TRISCbits.RC3
# define slotTime __delay_us(10)

//=========================================================
//--[ Declarações de funções ]--
void EEPROM_Write(unsigned, unsigned);
unsigned EEPROM_Read(unsigned);

//=========================================================
//--[ I2C comunicação ]--
void i2c_init() {
   SCL = 0; 	// Seta em zero para 
   SDA = 0; 	// não caracterizar como start e/ou stop   
   TRIS_SCL = 0;
   TRIS_SDA = 0;
}

void i2c_start() {
   SDA = 1;   // Seta data em 1
   slotTime;  // Tempo para estabilizar
   SCL = 1;   // Seta clock em 1
   slotTime;  // Tempo para estabilizar
   SDA = 0;   // Seta data em 0 no meio do clock para caracterizar o start bit
   slotTime;  // Tempo para estabilizar
   SCL = 0;   // Seta clock em 0 para finalizar o start bit
}

void i2c_stop() {
   SDA = 0;   // Seta data em 0
   slotTime;  // Tempor para estabilizar
   SCL = 1;   // Seta clock em 1
   slotTime;  // Tempor para estabilizar
   SDA = 1;   // Seta data em 1 no meio do clock para caracterizar o stop bit
   slotTime;  // Tempor para estabilizar
   SCL = 0;   // Seta clock em 0 para finalizar o stop bit
   slotTime;
}

void i2c_write(unsigned char val) {
   
   for(char i = 0; i < 8; i++) {
      
      if(val & 0x80) {
	 SDA = 1;
      } else {
	 SDA = 0;
      }     
      val = val << 1;
      slotTime; // Tempor para estabilizar
      SCL = 1;
      slotTime; // Tempor para estabilizar
      SCL = 0;
      slotTime; // Tempor para estabilizar
   }
}

unsigned char i2c_read() {
   unsigned char aux;
   TRIS_SDA = 1; // Linha de dados como entrada
   
   for(unsigned char i = 0; i < 8; i++) {
      SCL = 1;
      slotTime;  // Tempo para estabilizar     
      aux = (aux << 1) | SDA;    
      SCL = 0;
      slotTime;  // Tempo para estabilizar    
   }  
   TRIS_SDA = 0; // Linha de dados como saída 
   return aux;
}

unsigned char i2c_get_ack() {
   unsigned char aux;
   TRIS_SDA = 1;
   SCL = 1;
   slotTime;     // Tempor para estabilizar
   aux = SDA;
   SCL = 0;
   TRIS_SDA = 0;  
   return aux;
}

void i2c_send_ack() {
   SDA = 0;
   slotTime;
   SCL = 1;
   slotTime;
   SCL = 0;
}


void i2c_send_nack() {
   SDA = 1;
   slotTime;
   SCL = 1;
   slotTime;
   SCL = 0;
}

int read_data() {   //função de leitura da temperatura do termômetro
   i2c_start();
   i2c_write(0x90); // 1001 0000 -> Escrita
   if(i2c_get_ack()) { while(1); }
   
   i2c_write(0x00); // Tempo pointer
   if(i2c_get_ack()) { while(1); }
   
   i2c_start();
   i2c_write(0x91); // 1001 0001 -> Leitura
   if(i2c_get_ack()) { while(1); }
   
   unsigned char readMS = i2c_read(); // Dado MS
   i2c_send_ack();
   
   unsigned char readLS = i2c_read(); // Dado LS
   i2c_send_nack();
   i2c_stop();  
   return (readMS << 3) + (readLS >> 5);
}
//===========================================================================

void main(void)
 {
    TRISAbits.RA0 = 1; 
    TRISAbits.RA3 = 0;
    TRISAbits.RA4 = 1;
    TRISAbits.RA5 = 0; 		//usado nos leds minimo e máximo
    TRISAbits.RA6 = 0; 		//usado nos leds minimo e máximo
    TRISCbits.RC5 = 0;
    TRISCbits.RC6 = 0;
    TRISCbits.RC7 = 0;
    TRISB = 0x0F;
    TRISD = 0x00;
   
    ADCON0 = 0x01;
    /* 0b00000001
    *  bits 5:2 - seleção do canal AN0
    *  bit 1 - habilitado módulo de conversão
    */
    ADCON1 = 0x0E;
    /* 0b00001110
    *  bits 3:0 configura apenas a porta AN0 como entrada analógica
    *  bit 4:5 valores de referencia
    */
    ADCON2 = 0x1D;
    /* 0b00011101
       bit 7 - Justifica (formatação) a esquerda
       bits 5:3 - Tempo de aquisição 011 = 6 us
       bits 2:0 - Configuração de origem do clock para 16MHz.
		  16x62,5ns=1000ns (>700ns)

    */
    
    char numeros[11];		//vetor com os acendimentos para display
    numeros[0]=0x03F;		// de 7 segmentos.
    numeros[1]=0x06;
    numeros[2]=0x5B;
    numeros[3]=0x4F;       
    numeros[4]=0x66;
    numeros[5]=0x6D;
    numeros[6]=0x7D;
    numeros[7]=0x07;
    numeros[8]=0x7F;
    numeros[9]=0x6F;				
    numeros[10]=0xF9;
    
    int menor, maior, i;	//menor e maior  (i)= ajuste potenciometro
    unsigned char u,d,c,j=150, w = 0;	// unidade, centena, dezena, write 
    int m, termometro;	        // milhar, termometro
    
    i2c_init();
    
    menor = EEPROM_Read(0xFF);	// Leitura da memória interna (EEPROM)
    menor = menor + 100;
    maior = EEPROM_Read(0xFE);	// Leitura da memória interna (EEPROM)
    maior = maior + 100;
    
    while(1){
       ADCON0bits.GODONE = 1;
       if(j>=150){
	 termometro = read_data();	// Leitura do termômetro
	 __delay_ms(40);
	 termometro = termometro*1.25;	// Cálculo para colocar na mesma base
	
	 j=0;
       }
       j++;
	
   if (TEMP_TERM == 0){			// EXIBE VALOR DO TERMÔMETRO NO DISPLAY
	 LED_MAX = 0;
	 LED_MIN = 0;
	 LED_TERM = 1;
	 i = termometro;
   }
   
   if (TEMPERATURA==1 && HREC==0 && TEMP_TERM == 1){	//TEMPERATURA MENOR (ESCRITA)
	 LED_TERM = 0; 
      	 LED_MAX = 0;
	 LED_MIN = 1;
	 w = 1;
	 i = 100 + ADRESH;
	 if(i>maior) i = menor-1;
	 if(i<100) i = 100;
	 menor = i;
      }
      
    if (TEMPERATURA==0 && HREC==0 && TEMP_TERM == 1){	//TEMPERATURA MAIOR (ESCRITA)
	 LED_TERM = 0;
	 LED_MIN = 0;
	 LED_MAX = 1;	
	 w = 1;
	 i = 100 + ADRESH;
	 if(i>350) i = 350;
	 if(i<menor) i = menor+1;
	 maior = i; 
      }
      
      if(TEMPERATURA==1 && HREC==1 && TEMP_TERM == 1){	//TEMPERATURA MENOR (EXIBE)
	 LED_TERM = 0;
	 LED_MAX = 0;
	 LED_MIN = 1;
	 if(w ==1){
	    menor = menor - 100;
	    EEPROM_Write(0xFF, menor); 
	    menor = menor + 100;
	    w = 0;
	 }
	 i = menor;
      }
      if(TEMPERATURA==0 && HREC==1 && TEMP_TERM == 1){	//TEMPERATURA MAIOR (EXIBE)
	 LED_TERM = 0;
	 LED_MIN = 0;
         LED_MAX = 1;
	 if(w ==1){
	    maior = maior - 100;
	    EEPROM_Write(0xFE, maior); 
	    maior = maior + 100;
	    w = 0;
	 }
	 i = maior;
      }       
	      u = i%10;			// u recebe unidade.
	      m = i%100;
	      d = m/10;			// d recebe dezena.
	      m = i;
	      c = m/100;		// c recebe centena.
       
	      PORTB = 0b10000000;	
	      PORTD = numeros[d]; 	// exibe dezena
	      PORTDbits.RD7 = 1;
	      __delay_ms (2);
	      
	      
	      PORTB = 0b01000000; 	
	      PORTD = numeros[c];	//exibe centena
	       __delay_ms (2);
       
	       
	      PORTB = 0b00100000;
	      PORTD = numeros[0];	//exibe milhar (troquei o m por zero, para economizar uma op)
	     __delay_ms (2);
         
	     PORTB = 0b00010000;
	     PORTD = numeros[u];	//exibe unidade  
	     __delay_ms (2);
         
      if(menor > termometro){
	 LED_ACIMA = 0;
	 LED_DENTRO = 0;
	 LED_ABAIXO = 1;
      }
      if(maior < termometro){
	 LED_ABAIXO = 0;
	 LED_DENTRO = 0;
	 LED_ACIMA = 1;
      }
      if (menor < termometro && maior > termometro){
	 LED_ACIMA = 0;
	 LED_ABAIXO = 0;
	 LED_DENTRO = 1;
      }
   }
    return;
}
//=======================================================
//--[ Functinos Definitions ]--
void EEPROM_Write(unsigned Address, unsigned Data)
{
  while(EECON1bits.WR); // Aguarda até que a última tentativa de gravação seja concluída
  EEADR = Address;      // Escreve os Addres para os quais vamos mexer com nossos dados
  EEDATA = Data;        // Escreva os dados a serem salvos
  EECON1bits.EEPGD = 0; // Apagar para apontar para EEPROM não a memória do programa
  EECON1bits.WREN = 1;  // Ativar a operação!
  INTCONbits.GIE = 0;   // Desativar todas as interrupções até que os dados de gravação sejam concluídos
  EECON2 = 0x55;        // Parte do mecanismo de escrita...
  EECON2 = 0xAA;        // Parte do mecanismo de escrita...
  EECON1bits.WR = 1;    // Parte do mecanismo de escrita...
  INTCONbits.GIE = 1;   // Reativar interrupções
  EECON1bits.WREN = 0;  // Desativar a operação
  EECON1bits.WR = 0;    // Pronto para a próxima operação de escrita
}
unsigned EEPROM_Read(unsigned Address)
{
  unsigned Data;
  EEADR = Address;      // Escreva o endereço a partir do qual obteremos dados
  EECON1bits.EEPGD = 0; // Apagar para apontar para EEPROM não a memória do programa
  EECON1bits.RD = 1;    // Iniciar a operação de leitura
  Data = EEDATA;        // Leia os dados
  return Data; 
}